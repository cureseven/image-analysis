### 1．目的 
基本的な画像処理手法を習得し，それらの手法を画像処理問題へと応用できるようになること．

### 2．原理

#### 2 画像処理のプログラムについて  
画像処理は，画像に対して加工，変換を施し，必要があれば画像から情報を抽出して計測あるいは認識を行う処理である．

#### 3 画像ファイルの入出力について
##### 画像のデータについて  
コンピュータで扱う画像は，縦横に整列された点(画素)で構成されている．それぞれの画素には縦横それぞれに番号(整数)が振られており，それらの番号を画素の座標という．一般的に，横(x)方向には左から右にかけて，縦(y)方向には上から下に変えて0から順に座標値が与えられている．
また，各画素は，白黒濃淡画像では濃淡値，カラー画像ではカラー値と行った複数の画素値を持っている．よって，プログラムで画像を格納するためのデータ構造は，画素値をよう措置する2限配列またはポインタとするのが一般的である．

##### 画像入出力のための関数群  
###### PGM(白黒濃淡画像)用の構造体，関数
1. 画像格納のための構造体 GRAY_IMAGE  
```
typedef struct gray_image {
  int cols; /*横方向の画像の大きさ*/
  int rows; /*縦方向の画像の大きさ*/
  BYTE **p; /*各画素の濃淡値を格納した2元配列*/
  BYTE *data_p; /*各画素の濃淡値を格納したポインタ*/
} GRAY_IMAGE;
```

2. 指定した画像ファイルから画像データを入力する readGrayImage
```
GRAY_IMAGE * readGrayImage(char * filename)
　　char * filename 画像ファイル名
```
3. 指定した画像ファイルに画像データを出力する writeGrayImage
```
writeGrayImage(GRAY_IMAGE * image , char * filename)
 GRAY_IMAGE * image 画像データの構造体
 char * filename 画像ファイル名
```
4. 画像の大きさを指定して空の画像構造体を作成する allowGrayImage
```
GRAY_IMAGE * allocGrayImage(int cols, int rows)
 int cols /*画像の横の大きさ*/
 int rows /*画像の縦の大きさ*/
```
5. 指定した画像構造体を削除する freeGrayImage
```
freeGrayImage( GRAY_IMAGE * image)
 GRAY_IMAGE * image 画像データの構造体
```

###### PPM(カラー画像)用の構造体，関数
1. 画像格納のための構造体 RGB_PACKED_IMAGE  
```
typedef struct rgb_packed_image {
  int cols; /*横方向の画像の大きさ*/
  int rows; /*縦方向の画像の大きさ*/
  RGB_PACKED_PIXEL **p; /*各画素のRGB値を格納した2元配列*/
  RGB_PACKED_PIXEL *data_p; /*各画素のRGB値を格納したポインタ*/
} RGB_PACKED_IMAGE;
```

2. 指定した画像ファイルから画像データを入力する readRGBPackedImage
```
RGB_PACKED_IMAGE * readRGBPackedImage(char * filename)
　　char * filename 画像ファイル名
```
3. 指定した画像ファイルに画像データを出力する writeRGBPackedImage
```
writeRGBPackedImage(RGB_PACKED_IMAGE * image , char * filename)
 RGB_PACKED_IMAGE * image 画像データの構造体
 char * filename 画像ファイル名
```
4. 画像の大きさを指定して空の画像構造体を作成する allocRGBPackedImage
```
RGB_PACKED_IMAGE * allocRGBPackedImage(int cols, int rows)
 int cols /*画像の横の大きさ*/
 int rows /*画像の縦の大きさ*/
```
5. 指定した画像構造体を削除する freeRGBPackedImage
```
freeRGBPackedImage( RGB_PACKED_IMAGE * image)
 RGB_PACKED_IMAGE * image 画像データの構造体
```

##### コンパイルと実行
画像ファイル入出力ライブラリを用いて実行形式を作成するため，"gcc"コマンドではなく"make"コマンドでコンパイルを行う．したがってMakefileを作成する．  
実行は
```
% make sample
% ./sample

```


#### 4 表色系変換

色情報を扱う場合，RGB値よりも色相Hや彩度Sを用いた方が便利な場合がある．ここでは，(R,G,B -> Y,H,S)の変換を行う．
RGB値と輝度，色差との関係は次の式で表される．
```math
Y(x,y) = 0.2126R(x,y) + 0.7152G(x,y) +  0.0722B(x,y)   ---(1)
C_1(x,y) = (R(x,y) - Y(x,y))/1.5748 ---(2)
C_2(x,y) = (B(x,y) - Y(x,y))/1.8556 ---(3)  
```

または，  
```math
R(x,y) = Y(x,y) + 1.5748C1(x,y) ---(4)
G(x,y) = (Y(x,y) - 0.2126R(x,y) - 0.0722B(x,y))/0.7152 ---(5)
B(x,y) = Y(x,y) + 1.8556C2(x,y) ---(6)  
```
<!-- 5 -->
#### 5 画像の2値化
2値化は，ある画像を2つの値の画像(2値画像)に変換する処理である．
1. 試行錯誤的
自分で任意に設定した数種類の閾値で作成した2値画像を見比べて，最適な閾値を決定する方法である．
2. ヒストグラム方
閾値設定を自動化する方法の一つにヒストグラム法がある．これは，注目する物体の画素値をもつ画素とその背景の画素値をもつ画素がそれぞれ多いことを家庭した方法である．<br/>

<!-- 6 -->
#### 6 画像の拡大・縮小，回転，移動(アフィン変換)
画像の拡大，縮小，回転，移動は，元画像の各画素の座標に2次元アフィン変換を行うことで得られる．
###### 1. アフィン変換
元画像のがその座標を(x,y)，変換後の座標を(X,Y)とすると，2次元アフィン変換は次の一般式で表される．
```math
[X,Y,w]^-1=
\[
  A = \left(
    \begin{array}{ccc}
      a & b & c \\
      d & e & f \\
      0 & 0 & 1
    \end{array}
  \right)
\]
\[
  A = \left(
    \begin{array}{ccc}
      x \\
      y \\
      1
    \end{array}
  \right)
\]
```
###### 2. アフィン変換の式
###### 3. アフィン変換の実装
* 変換画像の作成について  
アフィン変換(拡大，縮小，回転，移動)された画像を作成するには，新たに作成する画像の座標(X,Y)の画素値p(X,Y)に，対応する元画像の座標(x,y)の画素値p(x,y)を設定すれば良い．<br/>
<br/>
* 画像の再標本化  
仮想的な画素の画素値を求める方法に最近隣内挿法や線形補間法がある．

* 最近隣内挿法
逆変換式で求めた元画像の画素の座標の画素値を最近隣内挿法で求める例を示す．最近隣内挿法では，値を求めたい座標(x,y)に最も近い座標の値をそのまま利用する．値を求めたい座標を(x,y)とするとその位置の画素値pnear(x,y)は次式で得られる．
```
pnear(x,y) = p([x+0.5],[y+0.5])
```
* 線形補間法  
逆変換式で求めた元画像の画素の座標(x,y)の画素値を線形補間法んで求める例を示す．線形補間法では，求めたい座標の画素値pnear(x,y)を，周囲の4点の画素値を用いて計算する．
```
pnear(x,y) = (1-sy){(1-sx) * p(|x|,|y|) + sx * p(|x|+1,|y|) + sy{(1-sx) * p(|x|,|y|+1) + sx * p(|x|+1,|y|+1)}}
```

* アフィン変換の手順  
以上をまとめると，
  1. 変換処理の逆変換の式のうち相応しいものを用いて，変換後の座標(X,Y)から変換前の座標(x,y)を求める
  2. 最近隣内挿法あるいは線形補間法により，座標(x,y)の画素値を求める．
  3. 求められた画素値を，返還後の画素(X,Y)の画素値とする．

<!-- 7 -->
#### 7 エッジ抽出
物体の輪郭線などエッジを得ることで，物体の形状などを調べることができる．エッジ抽出とは2値化と組み合わせて使用されることが多い．

###### 空間フィルタリング
注目している画素とその近傍の画素の画素値に重み付けをして，それらの話をとって注目している画素の新しい画素値とするような処理を近傍処理という．

###### 1次微分
座標にある画素について，横方向と縦方向の1次微分がそれぞれfx(x,y),fy(x,y)であるとき，座標(x,y)に置ける画素値の勾配(グラディエント)はベクトル(fx(x,y),fy(x,y))で表すことができる．この時，勾配の大きさと方向はそれぞれ
```
勾配の大きさ：sqrt(fx(x,y)^2 + fy(x,y)^2)
勾配の方向：arctan(fx(x,y)/fy(x,y))
```

###### 2次微分
エッジ強度は，画素値の2次微分でも得られる．

<!-- 8 -->
#### 8 画像のノイズ除去
イメージスキャナから画像を作成する場合，元の画像が劣化していたり，スキャナのガラス台が汚れていたりすると，画像データにノイズが加わる時がある．ここでは，画像のノイズ除去について扱う．
###### 平均値フィルタ
平均値フィルタは，注目している画素とその近傍の画素の画素値の平均を，注目している画素の新たな画素値とする．
###### メディアンフィルタ
メディアンフィルタは，注目している画素とその近傍の画素の画素値の中央値を，注目している画素の新たな画素値とする．


### 3. 実験結果
##### 演習1  
1. "sample.c"をコンパイル，実行し，作成される画像ファイルとソースファイルを確認．  
```
% make sample
```
でsampleができた．

2. "sample.c"に，入力画像と出力画像の座標(100,20)の画素値を端末に表示する処理を追加して，コンパイル，実行しその出力を確認せよ．
```
printf("%d\n", image_in -> p[20][100].r);
  printf("%d\n", image_in -> p[20][100].g);
  printf("%d\n", image_in -> p[20][100].b);
  printf("%d\n", image_out -> p[20][100]);
```

3. "sample.c"に，出力画像の座標(100,20)の画素値に100を代入する処理を追加して，コンパイル，実行しその出力を確認せよ．
```
image_out -> p[20][100] = 100;
```

4. "sample.c"に，入力画像の縦と横の大きさを端末に表示する処理を追加して，コンパイル，実行しその出力を確認せよ．
```
printf("縦のサイズ：%d\n", image_in -> rows);
  printf("横のサイズ：%d\n", image_in -> cols);
```

5. "sample.c"に，出力画像が入力画像の縦と横の大きさになるように修正して，コンパイル，実行しその出力を確認せよ．
```
image_out = allocGrayImage(image_in -> cols, image_in -> rows);
```
画像は真っ黒になった．

6. "sample.c"に，出力画像(入力画像と同じ大きさ)の全ての画素に255を代入する処理を追加して，コンパイル，実行しその出力を確認せよ．  
```
for(int i = 0; i < image_out -> cols; i++){
    for(int j = 0; j < image_out -> rows; j++){
      image_out -> p[j][i] = 255;
    }
  }
```
画像は真っ白になった．
<br/>

##### 演習2
「カラー画像から白黒濃淡画像への変換」について，
1. プログラムを作成し，動作を確認せよ
```
image_out -> p[j][i] = 0.2126*(image_in -> p[j][i].r) + 0.7152*(image_in -> p[j][i].g) + 0.0722*(image_in -> p[j][i].b);
```
とした．白黒濃淡画像ができた．
2. 関数化せよ
tomono.cというファイルを作成し，<br/>
  - 入力画像と同じ大きさの新規画像を作成
  - 新規画像の全ての画素の値を入力画像を用いて設定
を分けて処理した．<br/>
sample1.cにはプロトタイプ宣言を行った．

##### 演習3
「白黒濃淡画像の2値化」について，
1. 試行錯誤的に閾値を設定るす方法のプログラムを作成し，動作を確認せよ．
2. 関数化せよ．  
to2bit.cというファイルを作成し，<br/>
　- 入力画像と同じ大きさの新規画像を作成  
　- 新規画像の全ての画素の値を入力画像を用いて設定  
を分けて処理した．<br/>
sample1.cにはプロトタイプ宣言を行った．

##### 演習4
1. 横方向にx0,縦方向にy0の移動について，
  1. プログラムを作成し，動作を確認せよ．なお，変換前後の範囲に十分注意せよ．
  2. 関数化せよ．  
  <b>mv.c</b>に記述した．sample1.cにはプロトタイプ宣言を行った．
  <br/>
2. 横方向にrx倍，縦方向にry倍の拡大について，
  1. プログラムを作成し，動作を確認せよ．なお，変換前後の範囲に十分注意せよ．
  2. 関数化せよ．   
  <b>enlarge.c</b>に記述した．sample1.cにはプロトタイプ宣言を行った．

3. (x0,y0)を中心とする角θの回転について，
  1. プログラムを作成し，動作を確認せよ．なお，変換前後の範囲に十分注意せよ．  
  2. 関数化せよ．    
  <b>rotation.c</b>に記述した．sample1.cにはプロトタイプ宣言を行った．

4. 横方向にrx倍，縦方向にry倍の拡大と(x0,y0)を中心とする角θの回転について，補間法を線形補間法としたプログラムも作成し，処理結果の違いを考察せよ．  
最近隣内挿法を<b>rota-engage.c</b>に記述した．
線形補間法を<b>liner.c</b>に記述した．sample1.cにはそれぞれのプロトタイプ宣言を行った．また呼び出しに
```
img_out = roen(img_in);
```
```
img_out = liner(img_in);
```
を記述した．
<!-- 補間法を線形補間法とした時，画素値は近隣の画素を滑らかに繋ぐ値を取るので，色の変化が滑らかな画像になった． -->
liner.cではエラーが解決できていない．

##### 演習5
「エッジ抽出」について，
1. 3つのオペレータを用いたプログラムを作成し，白黒濃淡画像を用いて動作を確認せよ  

2. 関数化せよ

<!-- 3. オペレータを用いて作成したエッジを比較し，処理結果の違いを考察せよ．   -->
Robertsのオペレータを用いたエッジ抽出は<b>roberts.c</b>に，Sobelのオペレータを用いたエッジ抽出は<b>sobel.c</b>に，ラプラシアンのオペレータを用いたエッジ抽出は<b>laplacian.c</b>にそれぞれ記述した． sample1.cにはプロトタイプ宣言を行った．また呼び出しに
```
img_out = roberts(img_in);
```
```
img_out = sobel(img_in);
```
```
img_out = laplacian(img_in);
```
を記述した．



##### 演習6
1. 平均値フィルタによるノイズ除去についてプログラムを作成し，ノイズがくわわた白黒濃淡画像を用いて動作を確認せよ
2. メディアンフィルタによるノイズ除去についてプログラムを作成し，ノイズが加わった白黒濃淡画像を用いて動作を確認せよ
3. 関数化せよ．

平均値フィルタによるノイズ除去を<b>avr.c</b>に，メディアンフィルタによるノイズ除去を<b>median.c</b>に記述した．sample1.cにはプロトタイプ宣言を行った．また呼び出しに
```
img_out = avr(img_in);
```
```
img_out = median(img_in);
```
を記述した．
<!-- 4. 平均値フィルタとメディアンフィルタによるノイズ除去の結果を比較し，その違いを考察せよ． -->

### 4. 調査

### 5. 考察
##### 演習4：線形補間法と最近隣内挿法での処理結果の比較  
できていない．
##### 演習5：処理結果の比較
robertsのオペレータでは境界線が黒く，そのほかが白くなった．少しぼやけている．sobelのオペレータでは境界線は濃く太い黒になり，果実の模様が見えるようになった．laplacianのオペレータでは画像の端が黒くなり，くっきりとした線だが境界線は薄い線になった．
##### 演習6：処理結果の比較
平均値フィルタによるノイズ除去を行うと，白黒が反転した画像になった．境界線はぼやけた白になった．メディアンフィルタによるノイズ除去を行うと，模様がぼやけて見えないが色合いは元の画像とほとんど変わらない画像になった．

### 6. 参考文献
内村俊二・小林邦和・藤田悠介・間普真吾・佐村俊和 共著  
ものづくり創成実習Ⅰ・Ⅱテキスト

### 7. 添付資料
